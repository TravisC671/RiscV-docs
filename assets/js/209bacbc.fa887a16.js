"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[333],{2604:(s,e,i)=>{i.r(e),i.d(e,{assets:()=>x,contentTitle:()=>l,default:()=>c,frontMatter:()=>d,metadata:()=>n,toc:()=>a});const n=JSON.parse('{"id":"quick-reference/instructions","title":"AArch 64 Instructions","description":"adc - Add with carry","source":"@site/docs/quick-reference/instructions.mdx","sourceDirName":"quick-reference","slug":"/quick-reference/instructions","permalink":"/docs/quick-reference/instructions","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/quick-reference/instructions.mdx","tags":[],"version":"current","sidebarPosition":0,"frontMatter":{"sidebar_position":0},"sidebar":"tutorialSidebar","previous":{"title":"Quick Reference","permalink":"/docs/category/quick-reference"},"next":{"title":"Tutorial - Basics","permalink":"/docs/category/tutorial---basics"}}');var r=i(4848),t=i(8453);const d={sidebar_position:0},l="AArch 64 Instructions",x={},a=[{value:"Syntax",id:"syntax",level:2},{value:"Details",id:"details",level:2},{value:"Syntax",id:"syntax-1",level:2},{value:"Details",id:"details-1",level:2},{value:"Syntax",id:"syntax-2",level:2},{value:"Details",id:"details-2",level:2},{value:"Syntax",id:"syntax-3",level:2},{value:"Details",id:"details-3",level:2},{value:"Syntax",id:"syntax-4",level:2},{value:"Details",id:"details-4",level:2},{value:"Syntax",id:"syntax-5",level:2},{value:"Details",id:"details-5",level:2},{value:"Syntax",id:"syntax-6",level:2},{value:"Details",id:"details-6",level:2},{value:"Syntax",id:"syntax-7",level:2},{value:"Details",id:"details-7",level:2},{value:"Syntax",id:"syntax-8",level:2},{value:"Details",id:"details-8",level:2},{value:"Syntax",id:"syntax-9",level:2},{value:"Details",id:"details-9",level:2},{value:"Syntax",id:"syntax-10",level:2},{value:"Details",id:"details-10",level:2},{value:"Syntax",id:"syntax-11",level:2},{value:"Details",id:"details-11",level:2},{value:"Syntax",id:"syntax-12",level:2},{value:"Details",id:"details-12",level:2},{value:"Syntax",id:"syntax-13",level:2},{value:"Details",id:"details-13",level:2},{value:"Syntax",id:"syntax-14",level:2},{value:"Details",id:"details-14",level:2},{value:"Syntax",id:"syntax-15",level:2},{value:"Details",id:"details-15",level:2},{value:"Syntax",id:"syntax-16",level:2},{value:"Details",id:"details-16",level:2},{value:"Syntax",id:"syntax-17",level:2},{value:"Details",id:"details-17",level:2},{value:"Syntax",id:"syntax-18",level:2},{value:"Details",id:"details-18",level:2},{value:"Syntax",id:"syntax-19",level:2},{value:"Details",id:"details-19",level:2},{value:"Syntax",id:"syntax-20",level:2},{value:"Details",id:"details-20",level:2},{value:"Syntax",id:"syntax-21",level:2},{value:"Details",id:"details-21",level:2},{value:"Syntax",id:"syntax-22",level:2},{value:"Details",id:"details-22",level:2},{value:"Syntax",id:"syntax-23",level:2},{value:"Details",id:"details-23",level:2},{value:"Syntax",id:"syntax-24",level:2},{value:"Details",id:"details-24",level:2},{value:"Syntax",id:"syntax-25",level:2},{value:"Details",id:"details-25",level:2},{value:"Syntax",id:"syntax-26",level:2},{value:"Details",id:"details-26",level:2},{value:"Syntax",id:"syntax-27",level:2},{value:"Details",id:"details-27",level:2},{value:"Syntax",id:"syntax-28",level:2},{value:"Details",id:"details-28",level:2},{value:"Syntax",id:"syntax-29",level:2},{value:"Details",id:"details-29",level:2},{value:"Syntax",id:"syntax-30",level:2},{value:"Details",id:"details-30",level:2},{value:"Syntax",id:"syntax-31",level:2},{value:"Details",id:"details-31",level:2},{value:"Syntax",id:"syntax-32",level:2},{value:"Details",id:"details-32",level:2},{value:"Syntax",id:"syntax-33",level:2},{value:"Details",id:"details-33",level:2},{value:"Syntax",id:"syntax-34",level:2},{value:"Details",id:"details-34",level:2},{value:"Syntax",id:"syntax-35",level:2},{value:"Details",id:"details-35",level:2},{value:"Syntax",id:"syntax-36",level:2},{value:"Details",id:"details-36",level:2},{value:"Syntax",id:"syntax-37",level:2},{value:"Details",id:"details-37",level:2},{value:"Syntax",id:"syntax-38",level:2},{value:"Details",id:"details-38",level:2},{value:"Syntax",id:"syntax-39",level:2},{value:"Details",id:"details-39",level:2},{value:"Syntax",id:"syntax-40",level:2},{value:"Details",id:"details-40",level:2},{value:"Syntax",id:"syntax-41",level:2},{value:"Details",id:"details-41",level:2},{value:"Syntax",id:"syntax-42",level:2},{value:"Details",id:"details-42",level:2},{value:"Syntax",id:"syntax-43",level:2},{value:"Details",id:"details-43",level:2},{value:"Syntax",id:"syntax-44",level:2},{value:"Details",id:"details-44",level:2},{value:"Syntax",id:"syntax-45",level:2},{value:"Details",id:"details-45",level:2},{value:"Syntax",id:"syntax-46",level:2},{value:"Details",id:"details-46",level:2},{value:"Syntax",id:"syntax-47",level:2},{value:"Details",id:"details-47",level:2},{value:"Syntax",id:"syntax-48",level:2},{value:"Details",id:"details-48",level:2},{value:"Syntax",id:"syntax-49",level:2},{value:"Details",id:"details-49",level:2},{value:"Syntax",id:"syntax-50",level:2},{value:"Details",id:"details-50",level:2},{value:"Syntax",id:"syntax-51",level:2},{value:"Details",id:"details-51",level:2},{value:"Syntax",id:"syntax-52",level:2},{value:"Details",id:"details-52",level:2},{value:"Syntax",id:"syntax-53",level:2},{value:"Details",id:"details-53",level:2},{value:"Syntax",id:"syntax-54",level:2},{value:"Details",id:"details-54",level:2},{value:"Syntax",id:"syntax-55",level:2},{value:"Details",id:"details-55",level:2},{value:"Syntax",id:"syntax-56",level:2},{value:"Details",id:"details-56",level:2},{value:"Syntax",id:"syntax-57",level:2},{value:"Details",id:"details-57",level:2},{value:"Syntax",id:"syntax-58",level:2},{value:"Details",id:"details-58",level:2},{value:"Syntax",id:"syntax-59",level:2},{value:"Details",id:"details-59",level:2},{value:"Syntax",id:"syntax-60",level:2},{value:"Details",id:"details-60",level:2},{value:"Syntax",id:"syntax-61",level:2},{value:"Details",id:"details-61",level:2},{value:"Syntax",id:"syntax-62",level:2},{value:"Details",id:"details-62",level:2},{value:"Syntax",id:"syntax-63",level:2},{value:"Details",id:"details-63",level:2},{value:"Syntax",id:"syntax-64",level:2},{value:"Details",id:"details-64",level:2},{value:"Syntax",id:"syntax-65",level:2},{value:"Details",id:"details-65",level:2},{value:"Syntax",id:"syntax-66",level:2},{value:"Details",id:"details-66",level:2},{value:"Syntax",id:"syntax-67",level:2},{value:"Details",id:"details-67",level:2},{value:"Syntax",id:"syntax-68",level:2},{value:"Details",id:"details-68",level:2},{value:"Syntax",id:"syntax-69",level:2},{value:"Details",id:"details-69",level:2},{value:"Syntax",id:"syntax-70",level:2},{value:"Details",id:"details-70",level:2},{value:"Syntax",id:"syntax-71",level:2},{value:"Details",id:"details-71",level:2},{value:"Syntax",id:"syntax-72",level:2},{value:"Details",id:"details-72",level:2}];function h(s){const e={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",strong:"strong",...(0,t.R)(),...s.components},{Details:i}=e;return i||function(s,e){throw new Error("Expected "+(e?"component":"object")+" `"+s+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"aarch-64-instructions",children:"AArch 64 Instructions"})}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"adc"})," - Add with carry"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 86"})}),(0,r.jsx)(e.h2,{id:"syntax",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"addc{s} Rd, Rn, Rm"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"{s}"})," (optional) determines if the operation affects the PSTATE ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rd"})," is the destination register where the sum is stored ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rn,"})," Rm are the registers to be added together ",(0,r.jsx)("br",{})]}),(0,r.jsx)(e.h2,{id:"details",children:"Details"}),(0,r.jsxs)(e.p,{children:["This operation adds the carry bit from the PSTATE ",(0,r.jsx)("br",{})," Rd <- Rn + Rm + carry"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"add"})," - Add"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 86"})}),(0,r.jsx)(e.h2,{id:"syntax-1",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"add{s} Rd, Rn, <Operand2>"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"{s}"})," (optional) determines if the operation affects the PSTATE ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rd"})," is the destination register where the sum is stored ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rn"})," is the register to be added to ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"<Operand2>"})," tbd"]}),(0,r.jsx)(e.h2,{id:"details-1",children:"Details"}),(0,r.jsxs)(e.p,{children:["This operation adds two registers together, with some extra options ",(0,r.jsx)("br",{})," Rd <- Rn + Rx"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"adr"})," - Form PC-Relative Address"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 78"})}),(0,r.jsx)(e.h2,{id:"syntax-2",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"adr Rd, <label>"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rd"})," is the destination register where the 64-bit address will be stored ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"is"})," the label where the address is stored,"]}),(0,r.jsx)(e.h2,{id:"details-2",children:"Details"}),(0,r.jsxs)(e.p,{children:["This instruction is more efficient than ldr Rx, = Label because it can calculate the 64-bit address in one or two instructions without performing memory access. Has a range of +- 1 MB (adrp has a range of +- 4 GB) ",(0,r.jsx)("br",{})," Rd <- address of label"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"adrp"})," - Form PC-Relative Address to 4 KB Page"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 78"})}),(0,r.jsx)(e.h2,{id:"syntax-3",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"adr Rd, <label>"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rd"})," is the destination register where the 64-bit address will be stored ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"is"})," the label where the address is stored,"]}),(0,r.jsx)(e.h2,{id:"details-3",children:"Details"}),(0,r.jsxs)(e.p,{children:["adrp has a range of +-4 GB to the nearest 4 KB page (4096 bytes). The 21-bit immediate is shifted left by 12 bits and added to the PC. ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," The lower 12 bits of a label's address can be added to adrp to exactly address a label. ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," rd <- page address of <label>"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"and"})," - Bitwise AND"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 88"})}),(0,r.jsx)(e.h2,{id:"syntax-4",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"and{s} Rd, Rn, <Operand2>"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"{s}"})," (optional) determines if the operation affects the PSTATE ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rd"})," is the destination register where the result is stored ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rn"})," is the register that is anded  ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"<Operand2>"})," tbd"]}),(0,r.jsx)(e.h2,{id:"details-4",children:"Details"}),(0,r.jsxs)(e.p,{children:["Uses the bitwise AND operation between the two registers ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," Rd <- Rn AND <Operand2>"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"asr"})," - Arithmetic shift right"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 91"})}),(0,r.jsx)(e.h2,{id:"syntax-5",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"asr Rd, Rn, Rm"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rd"})," is the destination register where the result is stored ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rn"})," is the register that the shift is performed on ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rm"})," is the register that is used as the shift amount"]}),(0,r.jsx)(e.h2,{id:"details-5",children:"Details"}),(0,r.jsxs)(e.p,{children:["asr shifts the bits to the right by the amount of Rm, but it keeps the sign of the original value ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," Ex. ",(0,r.jsx)("br",{})," 1011 0110 >> 2 ",(0,r.jsx)("br",{})," Result: ",(0,r.jsx)("br",{})," 1110 1101"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"b"})," - Branch"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 70"})}),(0,r.jsx)(e.h2,{id:"syntax-6",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"b{<cond>} <target_label>"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"<cond>"})," (optional) the condition that if true, the program will goto the target_label the list of conditions can be found here(TBD) ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"<target_label>"})," can be any label in the current file or any label that is defined as .global(or .global) in any file that is linked"]}),(0,r.jsx)(e.h2,{id:"details-6",children:"Details"}),(0,r.jsxs)(e.p,{children:["This puts the new address inside the PC address. ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," This can make conditional logic such as loop and if-then-else constructs."]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"bic"})," - Bitwise Bit Clear"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 89"})}),(0,r.jsx)(e.h2,{id:"syntax-7",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"bic{s} Rd, Rn, <Operand2>"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rd"})," is the destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rn"})," is the register that has the bic applied with the register in <Operand2>"]}),(0,r.jsx)(e.h2,{id:"details-7",children:"Details"}),(0,r.jsxs)(e.p,{children:["The bit clear operation is pretty much like a mask that only keeps the bits in <Operand2> that are set to zero. The operation looks like this ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," Ex. ",(0,r.jsx)("br",{})," Rn = 1011 0110 ",(0,r.jsx)("br",{})," op = 1111 1000 -> 0000 0111 ",(0,r.jsx)("br",{})," Rd = 0000 0110 ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," Rd <- Rn AND NOT(<Operand2>)"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"bl"})," - Branch and Link"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 73"})}),(0,r.jsx)(e.h2,{id:"syntax-8",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"bl <target_address>"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"<target_address>"})," can be any label in the current file or any label defined as .global(or .global) within the range of +-128MB"]}),(0,r.jsx)(e.h2,{id:"details-8",children:"Details"}),(0,r.jsx)(e.p,{children:"Saves the address of the next instruction in link register (x30), then load PC with new address"})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"blr"})," - Branch to Register and Link"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 73"})}),(0,r.jsx)(e.h2,{id:"syntax-9",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"blr Xn"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Xn"})," contains the address of the next instruction"]}),(0,r.jsx)(e.h2,{id:"details-9",children:"Details"}),(0,r.jsxs)(e.p,{children:["Saves the address of the next instruction in link register (x30), then loads PC with Xn ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," X30 <- PC + 4 ",(0,r.jsx)("br",{})," PC <- Xn"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"br"})," - Branch to Register"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 72"})}),(0,r.jsx)(e.h2,{id:"syntax-10",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"br Xn"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Xn"})," register that will be copied to the program counter (PC)"]}),(0,r.jsx)(e.h2,{id:"details-10",children:"Details"}),(0,r.jsxs)(e.p,{children:["Copies register Xn to the program counter (PC) ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," PC <- Xn"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"cbnz"})," - Compare and Branch if Nonzero"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 76"})}),(0,r.jsx)(e.h2,{id:"syntax-11",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"cbnz Rt, <label>"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rt"})," The register that will be tested. if nonzero, it will go to the label ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"<label>"})," can be any label in the file, must be word-aligned"]}),(0,r.jsx)(e.h2,{id:"details-11",children:"Details"}),(0,r.jsxs)(e.p,{children:["Conditionally branches to the label if Rt is nonzero. has a range of +- 1MB ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," if Rt != 0 then ",(0,r.jsx)("br",{}),"     PC <- label ",(0,r.jsx)("br",{})," end if"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"cbz"})," - Compare and Branch if Zero"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 76"})}),(0,r.jsx)(e.h2,{id:"syntax-12",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"cbz Rt, <label>"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rt"})," The register that will be tested. if zero, it will go to the label ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"<label>"})," can be any label in the file, must be word-aligned"]}),(0,r.jsx)(e.h2,{id:"details-12",children:"Details"}),(0,r.jsxs)(e.p,{children:["Conditionally branch to label if Rt is zero ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," if Rt = 0 then ",(0,r.jsx)("br",{}),"     PC <- label ",(0,r.jsx)("br",{})," end if"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"ccmn"})," - Conditional Compare Negative"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 101"})}),(0,r.jsx)(e.h2,{id:"syntax-13",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"ccmn Rn, Rm|#<imm5>, #<nzcv>, <cond>"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rn"})," register to be added with Rm|#<imm5> and set to PSTATE ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rm|#<imm5>"})," either is a register or an unsigned 5-bit immediate ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"#<nzcv>"})," oa value between 0-15, representing the NZCV PSTATE flags ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"<cond>"})," condition that will be used for comparison."]}),(0,r.jsx)(e.h2,{id:"details-13",children:"Details"}),(0,r.jsxs)(e.p,{children:["Test and set PSTATE flags to a negated comparison or immediate ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," if <cond> then ",(0,r.jsx)("br",{}),"     PSTATE <- flags(Rn+Rm|imm5) ",(0,r.jsx)("br",{})," else ",(0,r.jsx)("br",{}),"     PSTATE <- <nzcv> ",(0,r.jsx)("br",{})," end if"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"ccmp"})," - Conditional Compare"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 101"})}),(0,r.jsx)(e.h2,{id:"syntax-14",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"ccmp Rn, Rm|#<imm5>, #<nzcv>, <cond>"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rn"})," register to be subtracted by Rm|#<imm5> ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rm|#<imm5>"})," either is a register or an unsigned 5-bit immediate ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"#<nzcv>"})," oa value between 0-15, representing the NZCV PSTATE flags ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"<cond>"})," condition that will be used for comparison."]}),(0,r.jsx)(e.h2,{id:"details-14",children:"Details"}),(0,r.jsxs)(e.p,{children:["Test and set PSTATE to a comparison or immediate ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," if <cond> then ",(0,r.jsx)("br",{}),"     PSTATE <- flags(Rn-Rm|imm5) ",(0,r.jsx)("br",{})," else ",(0,r.jsx)("br",{}),"     PSTATE <- <nzcv> ",(0,r.jsx)("br",{})," end if"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"cinc"})," - conditional increment"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 100"})}),(0,r.jsx)(e.h2,{id:"syntax-15",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"cinc Rd, Rn, <cond>"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rd"})," is the destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rn"})," is the register that is set to Rd and may be incremented if <cond> is true ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"<cond>"})," condition that will be used for comparison."]}),(0,r.jsx)(e.h2,{id:"details-15",children:"Details"}),(0,r.jsxs)(e.p,{children:["Set Rd to Rn + 1 if true or Rn if false ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," if <cond> then ",(0,r.jsx)("br",{}),"     Rd <- Rn + 1 ",(0,r.jsx)("br",{})," else ",(0,r.jsx)("br",{}),"     Rd <- Rn ",(0,r.jsx)("br",{})," end if"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"cinv"})," - Conditional Invert"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 100"})}),(0,r.jsx)(e.h2,{id:"syntax-16",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"cinv Rd, Rn, Rm, <cond>"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rd"})," is the destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rn"})," is the register that is inverted then stored to Rd if <cond> is true ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rm"})," is the register that is stored in Rd if <cond> is false ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"<cond>"})," condition that will be used for comparison."]}),(0,r.jsx)(e.h2,{id:"details-16",children:"Details"}),(0,r.jsxs)(e.p,{children:["Set Rd to inverted Rn if true or Rn if false ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," if <cond> then ",(0,r.jsx)("br",{}),"     Rd <- NOT(Rn) ",(0,r.jsx)("br",{})," else ",(0,r.jsx)("br",{}),"     Rd <- Rn ",(0,r.jsx)("br",{})," end if"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"cls"})," - Count Leading Sign Bits"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 104"})}),(0,r.jsx)(e.h2,{id:"syntax-17",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"cls Rd, Rn"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rd"})," stores the result of the leading sign bits in Rn ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rn"})," register to be operated on"]}),(0,r.jsx)(e.h2,{id:"details-17",children:"Details"}),(0,r.jsxs)(e.p,{children:["Counts leading sign bits in Rn ",(0,r.jsx)("br",{})," If Rn is negative it will count the ones at the beginning, and if it's positive it will count the zeros ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," Rd <- CountLeadingSignBits(Rn)"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"clz"})," - Count Leading Zeros"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 104"})}),(0,r.jsx)(e.h2,{id:"syntax-18",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"clz Rd, Rn"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rd"})," stores the result of the leading zeros in Rn ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rn"})," register to be operated on"]}),(0,r.jsx)(e.h2,{id:"details-18",children:"Details"}),(0,r.jsxs)(e.p,{children:["Counts the leading zeros in Rn ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," Rd <- CountLeadingZeros(Rn)"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"cmn"})," - Compare Negative"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 98"})}),(0,r.jsx)(e.h2,{id:"syntax-19",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"cmn Rn, <Operand2>"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rn"})," Register to be compared with <Operand2> ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"<Operand2>"})," tbd"]}),(0,r.jsx)(e.h2,{id:"details-19",children:"Details"}),(0,r.jsxs)(e.p,{children:["Compare negative and set PSTATE flags ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," Rn + operand2"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"cmp"})," - Compare"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 98"})}),(0,r.jsx)(e.h2,{id:"syntax-20",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"cmp Rn, <Operand2>"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rn"})," Register to be compared with <Operand2> ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"<Operand2>"})," tbd"]}),(0,r.jsx)(e.h2,{id:"details-20",children:"Details"}),(0,r.jsxs)(e.p,{children:["Compare and set PSTATE flags ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," Rn - operand2"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"cneg"})," - Conditional Negate"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 101"})}),(0,r.jsx)(e.h2,{id:"syntax-21",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"cneg Rd, Rn, <cond>"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rd"})," is the destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rn"})," is the register to be stored to Rd and negated if <cond> is true ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"<cond>"})," condition that will be used for comparison."]}),(0,r.jsx)(e.h2,{id:"details-21",children:"Details"}),(0,r.jsxs)(e.p,{children:["set Rd to Rn negated if <cond> is true or Rn if false ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," If <cond> then ",(0,r.jsx)("br",{}),"     Rd <- 1 + NOT(Rn) ",(0,r.jsx)("br",{})," else ",(0,r.jsx)("br",{}),"     Rd <- Rn ",(0,r.jsx)("br",{})," end if ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"csel"})," - Conditional Select"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 100"})}),(0,r.jsx)(e.h2,{id:"syntax-22",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"csel Rd, Rn, Rm, <cond>"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rd"})," is the destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rn"})," register that will be stored in Rd if <cond> is true ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rm"})," register that will be stored in Rd if <cond> is false"]}),(0,r.jsx)(e.h2,{id:"details-22",children:"Details"}),(0,r.jsxs)(e.p,{children:["Set Rd to Rn if <cond> is true or Rm if <cond> is false ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," if <cond> then ",(0,r.jsx)("br",{}),"     Rd <- Rn ",(0,r.jsx)("br",{})," else ",(0,r.jsx)("br",{}),"     Rd <- Rm ",(0,r.jsx)("br",{})," end if ",(0,r.jsx)("br",{})]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"cset"})," - Conditional Set"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 101"})}),(0,r.jsx)(e.h2,{id:"syntax-23",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"cset Rd, <cond>"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rd"})," is the destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"<cond>"})," condition that will be used for comparison."]}),(0,r.jsx)(e.h2,{id:"details-23",children:"Details"}),(0,r.jsxs)(e.p,{children:["Set Rd to 1 if <cond> is true or 0 if false ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," if <cond> then ",(0,r.jsx)("br",{}),"     Rd <- 1 ",(0,r.jsx)("br",{})," else ",(0,r.jsx)("br",{}),"     Rd <- 0 ",(0,r.jsx)("br",{})," end if"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"csetm"})," - Conditional Set Mask"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 101"})}),(0,r.jsx)(e.h2,{id:"syntax-24",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"csetm Rd, <cond>"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rd"})," is the destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"<cond>"})," condition that will be used for comparison."]}),(0,r.jsx)(e.h2,{id:"details-24",children:"Details"}),(0,r.jsxs)(e.p,{children:["Fill Rd with ones or zeros ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," if <cond> then ",(0,r.jsx)("br",{}),"     Rd <- 0xffffffffffffffff ",(0,r.jsx)("br",{})," else ",(0,r.jsx)("br",{}),"     Rd <- 0x0000000000000000 ",(0,r.jsx)("br",{})," end if"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"csinc"})," - Conditional Select Increment"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 100"})}),(0,r.jsx)(e.h2,{id:"syntax-25",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"csinc Rd, Rn, Rm, <cond>"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rd"})," is the destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rn"})," is the register that is set to Rd if <cond> is true ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rm"})," is the register that is incremented and set to Rd if <cond> is false"]}),(0,r.jsx)(e.h2,{id:"details-25",children:"Details"}),(0,r.jsxs)(e.p,{children:["Set Rd to Rn if <cond> is true or Rm + 1 if <cond> is false ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," if <cond> then ",(0,r.jsx)("br",{}),"     Rd <- Rn ",(0,r.jsx)("br",{})," else ",(0,r.jsx)("br",{}),"     Rd <- Rm + 1 ",(0,r.jsx)("br",{})," end if"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"csinv"})," - Conditional Select Invert"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 100"})}),(0,r.jsx)(e.h2,{id:"syntax-26",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"csinv Rd, Rn, Rm, <cond>"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rd"})," is the destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rn"})," is the register that is set to Rd if <cond> is true ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rm"})," is the register that is inverted and set to Rd if <cond> is false"]}),(0,r.jsx)(e.h2,{id:"details-26",children:"Details"}),(0,r.jsxs)(e.p,{children:["Set Rd to Rn if <cond> is true or NOT(Rm) if <cond> is false ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," if <cond> then ",(0,r.jsx)("br",{}),"     Rd <- Rn ",(0,r.jsx)("br",{})," else ",(0,r.jsx)("br",{}),"     Rd <- Rm + 1 ",(0,r.jsx)("br",{})," end if"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"csneg"})," - Conditional Select Negate"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 100"})}),(0,r.jsx)(e.h2,{id:"syntax-27",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"csneg Rd, Rn, Rm, <cond>"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rd"})," is the destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rn"})," is the register that is set to Rd if <cond> is true ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rm"})," is the register that is negated and set to Rd if <cond> is false ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"<cond>"})," condition that will be used for comparison."]}),(0,r.jsx)(e.h2,{id:"details-27",children:"Details"}),(0,r.jsxs)(e.p,{children:["Set Rd to Rn if <cond> is true or NOT(Rm) + 1 if <cond> is false ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," if <cond> then ",(0,r.jsx)("br",{}),"     Rd <- Rn ",(0,r.jsx)("br",{})," else ",(0,r.jsx)("br",{}),"     Rd <- 1 + NOT(Rm) ",(0,r.jsx)("br",{})," end if"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"eon"})," - Bitwise Exclusive  OR NOT"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 89"})}),(0,r.jsx)(e.h2,{id:"syntax-28",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"eon Rd, Rn, <Operand2>"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rd"})," is the destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rn"})," is the register that is operated on ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"<Operand2>"})," tbd"]}),(0,r.jsx)(e.h2,{id:"details-28",children:"Details"}),(0,r.jsxs)(e.p,{children:["Bitwise Exclusive OR NOT ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," Rd <- Rn XOR NOT(<OPERAND2>)"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"eor"})," - Bitwise Exclusive OR"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 89"})}),(0,r.jsx)(e.h2,{id:"syntax-29",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"eon Rd, Rn, <Operand2>"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rd"})," is the destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rn"})," is the register that is operated on ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"<Operand2>"})," tbd"]}),(0,r.jsx)(e.h2,{id:"details-29",children:"Details"}),(0,r.jsxs)(e.p,{children:["Bitwise Exclusive OR (XOR) ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," Rd <- Rn XOR <Operand2>"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"ldp"})," - Load Pair"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 68"})}),(0,r.jsx)(e.h2,{id:"syntax-30",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"ldp{<size>} Rt, Rt2, <addr>"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"<size>"})," is optionally sw for signed words ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rt"})," is the first register to be stored ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rt2"})," is the first register to be stored ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"<adr>"})," is 7 bits Pre-indexed, Post-indexed, or Signed immediate (Signed immediate Xt range [-0x200, 0x1f8]. Wt range: [-0x100, 0xfc])"]}),(0,r.jsx)(e.h2,{id:"details-30",children:"Details"}),(0,r.jsxs)(e.p,{children:["Load register pair from memory at addr where sizeof(Rt) is 4 for Wt registers and 8 for Xt registers ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," Rt  <- Mem[addr] ",(0,r.jsx)("br",{})," Rt2 <- Mem[addr+size(Rt)]"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"ldr"})," - Load Register"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 65"})}),(0,r.jsx)(e.h2,{id:"syntax-31",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"ldr{<size>} Rd, <addr>"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rd"})," is the destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"<addr>"})," is one of the address specifiers described in (TBD) ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"<size>"})," (optional) is one of: ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"b"})," unsigned byte ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"h"})," unsigned half-word ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"sb"})," signed byte ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"sh"})," signed half-word ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"sw"})," signed word"]}),(0,r.jsx)(e.h2,{id:"details-31",children:"Details"}),(0,r.jsxs)(e.p,{children:["Load register from memory at addr ",(0,r.jsx)("br",{})," Rd <- Mem[addr]"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"ldur"})," - Load Register (Unscaled)"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 67"})}),(0,r.jsx)(e.h2,{id:"syntax-32",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"ldur{<size>} Rd, [Xn, #imm9]"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rd"})," is the destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"[Xn,"})," #imm9] The addressing mode is signed immediate with 9 bits ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"<size>"})," is optional and can be one of: ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"b"})," unsigned byte ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"h"})," unsigned half-word ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"sb"})," signed byte ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"sh"})," signed half-word ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"sw"})," signed word"]}),(0,r.jsx)(e.h2,{id:"details-32",children:"Details"}),(0,r.jsxs)(e.p,{children:["Load register from memory at addr ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," Rd <- Mem[addr] ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," ex. ",(0,r.jsx)("br",{})," Load the byte from Mem[x5 + 255]. sign extend it and store the value in x4 ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," ldursb x4, [x5, #255]"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"lsl"})," - Logical Shift Left"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 91"})}),(0,r.jsx)(e.h2,{id:"syntax-33",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"lsl Rd, Rn, Rm"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rd"})," is the destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rn"})," is the register to be operated on ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rm"})," is the register that stores the shift amount"]}),(0,r.jsx)(e.h2,{id:"details-33",children:"Details"}),(0,r.jsxs)(e.p,{children:["Shift left ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," Ex. ",(0,r.jsx)("br",{})," shift the bits of Rn to the left by 2 ",(0,r.jsx)("br",{})," mov x2, #2 ",(0,r.jsx)("br",{})," lsl x0, x1, x2 ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," x1 = 1011 0110 ",(0,r.jsx)("br",{})," Rd = 1101 1000 ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," Rd <- Rn << Rm"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"lsr"})," - Logical Shift Right"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 91"})}),(0,r.jsx)(e.h2,{id:"syntax-34",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"lsr Rd, Rn, Rm"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rd"})," is the destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rn"})," is the register to be operated on ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rm"})," is the register that stores the shift amount"]}),(0,r.jsx)(e.h2,{id:"details-34",children:"Details"}),(0,r.jsxs)(e.p,{children:["Shift left ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," Ex. ",(0,r.jsx)("br",{})," shift the bits of Rn to the right by 2 ",(0,r.jsx)("br",{})," mov x2, #2 ",(0,r.jsx)("br",{})," lsr x0, x1, x2 ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," x1 = 1011 0110 ",(0,r.jsx)("br",{})," Rd = 0010 1101 ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," Rd <- Rn >> Rm"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"madd"})," - Multiply Add"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 92"})}),(0,r.jsx)(e.h2,{id:"syntax-35",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"madd Rd, Rn, Rm, Ra"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rd"})," is the destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rn"})," is the register to be multiplied with Rm ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rm"})," is the register to be multiplied with Rn ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Ra"})," is the register to be added with Rm*Rn"]}),(0,r.jsx)(e.h2,{id:"details-35",children:"Details"}),(0,r.jsxs)(e.p,{children:["Multiply Rm and Rn, then adds Ra and stores the result in Rd ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," Rd <- Ra+(Rn*Rm)"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"mneg"})," - Multiply Negate"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 92"})}),(0,r.jsx)(e.h2,{id:"syntax-36",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"mneg Rd, Rn, Rm"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rd"})," is the destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rn"})," is the register to be multiplied with Rm ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rm"})," is the register to be multiplied with Rn"]}),(0,r.jsx)(e.h2,{id:"details-36",children:"Details"}),(0,r.jsxs)(e.p,{children:["Multiplies Rm and Rn, and then multiplies the result of -1 and stores it in Rd. mneg is an alias for msub and sets Ra to ZR ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," Rd <- -(Rn*Rm)"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"mov"})," - Move"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 90"})}),(0,r.jsx)(e.h2,{id:"syntax-37",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"mov Rd|SP, Rn|SP"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rd|SP"})," is either the destination register or stack pointer ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rn"})," general purpose register ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"mov"})," Rd, #<imm16>|#<pattern> ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rd"})," is the destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"#<imm16>"})," is a 16 bit long number ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"#<pattern>"})," tbd"]}),(0,r.jsx)(e.h2,{id:"details-37",children:"Details"}),(0,r.jsxs)(e.p,{children:["The mov instruction is an alias, chosen by the assembler, which is either orr, movz, movn, or add instructions. It facilitates choosing an immediate value or moving a register value to or from the stack pointer ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," Move General purpose register to or from sp or two and from another general purpose register ",(0,r.jsx)("br",{})," Rd|SP <- Rd|sp ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," Move an immediate to the destination register ",(0,r.jsx)("br",{})," Rd <- #<imm16> or #<pattern>"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"movk"})," - Move wide with Keep"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 90"})}),(0,r.jsx)(e.h2,{id:"syntax-38",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"movk Rd, #<imm16>{, lsl #<shift>}"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rd"})," is the destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"#<imm16>"})," is a 16-bit value ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"{,"})," lsl #<shift>} is optional and allows you to left shift the immediate value by a specific amount for a 64-bit or 32-bit register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"64-bit:"})," 0, 16, 32, 48 ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"32-bit:"})," 0, 16"]}),(0,r.jsx)(e.h2,{id:"details-38",children:"Details"}),(0,r.jsxs)(e.p,{children:["Any 64-bit value can be loaded with 4 movk instructions. If it is a pattern, it can be done with just one mov instruction, which is an alias for orr ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," sets only four bits and keeps the rest of the number ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," rd[shift + 15: shift] <- (imm16 << shift)"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"movn"})," - Move wide with NOT"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 90"})}),(0,r.jsx)(e.h2,{id:"syntax-39",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"movk Rd, #<imm16>{, lsl #<shift>}"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rd"})," is the destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"#<imm16>"})," is a 16-bit value ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"{,"})," lsl #<shift>} is optional and allows you to left shift the immediate value by a specific amount for a 64-bit or 32-bit register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"64-bit:"})," 0, 16, 32, 48 ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"32-bit:"})," 0, 16"]}),(0,r.jsx)(e.h2,{id:"details-39",children:"Details"}),(0,r.jsxs)(e.p,{children:["Sets the register to the 1's complement of the shifted immediate ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," Rd <- NOT(imm16<<shift)"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"movz"})," - Move wide with Zero"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 90"})}),(0,r.jsx)(e.h2,{id:"syntax-40",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"movk Rd, #<imm16>{, lsl #<shift>}"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rd"})," is the destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"#<imm16>"})," is a 16-bit value ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"{,"})," lsl #<shift>} is optional and allows you to left shift the immediate value by a specific amount for a 64-bit or 32-bit register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"64-bit:"})," 0, 16, 32, 48 ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"32-bit:"})," 0, 16"]}),(0,r.jsx)(e.h2,{id:"details-40",children:"Details"}),(0,r.jsxs)(e.p,{children:["Set the register to the immediate shifted ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," Rd <- imm16 << shift"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"mrs"})," - Move Status to Register"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 105"})}),(0,r.jsx)(e.h2,{id:"syntax-41",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"mrs Xt, <field>"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Xt"})," is the destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"<field>"})," is optional and is one of ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"NZCV"})," Condition Flags ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"FAIR"})," Interrupt Bits ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"CurrentEl"})," Current Exeption Level ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"PAN"})," Privileged Access Never(ARMv8.1 only) ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"UAO"})," User Access Override (ARMv8.2-UAO only)"]}),(0,r.jsx)(e.h2,{id:"details-41",children:"Details"}),(0,r.jsxs)(e.p,{children:["Move from Process State ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," Xt <- PSTATE ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," mrs x0, NZCV    //read the NZCV flags into r0 ",(0,r.jsx)("br",{})," and x0, xzr, z0 //clear the flags ",(0,r.jsx)("br",{})," msr NZCV, x0    // Write the flags back"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"msr"})," - Move Register to Status"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 105"})}),(0,r.jsx)(e.h2,{id:"syntax-42",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"msr <field>, Xt"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Xt"})," is the register to be put in <field> ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"<field>"})," is optional and is one of ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"NZCV"})," Condition Flags ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"FAIR"})," Interrupt Bits ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"CurrentEl"})," Current Exeption Level ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"PAN"})," Privileged Access Never(ARMv8.1 only) ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"UAO"})," User Access Override (ARMv8.2-UAO only)"]}),(0,r.jsx)(e.h2,{id:"details-42",children:"Details"}),(0,r.jsxs)(e.p,{children:["Move to Process State ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," PSTATE <- Xt ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," mrs x0, NZCV    //read the NZCV flags into r0 ",(0,r.jsx)("br",{})," and x0, xzr, z0 //clear the flags ",(0,r.jsx)("br",{})," msr NZCV, x0    // Write the flags back"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"msub"})," - Multiply Subtract"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 92"})}),(0,r.jsx)(e.h2,{id:"syntax-43",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"msub Rd, Rn, Rm, Ra"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rd"})," is the destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rn"})," is the register to be multiplied by Rm ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rm"})," is the register to be multiplied by Rn ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Ra"})," is the register to be subtracted"]}),(0,r.jsx)(e.h2,{id:"details-43",children:"Details"}),(0,r.jsxs)(e.p,{children:["Multiply Rn and Rm, then subtract the result from Ra and store it in Rd ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," Rd <- Ra-(Rn*Rm)"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"mul"})," - Multiply"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 92"})}),(0,r.jsx)(e.h2,{id:"syntax-44",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"mul Rd, Rn, Rm"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rd"})," is the destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rn"})," is the register to be multiplied by Rm ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rm"})," is the register to be multiplied by Rn"]}),(0,r.jsx)(e.h2,{id:"details-44",children:"Details"}),(0,r.jsxs)(e.p,{children:["mul is an alias for madd and sets Ra to ZR ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," multiplies Rn by Rm ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," Rd <- Rn*Rm"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"mvn"})," - bitwise NOT"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 89"})}),(0,r.jsx)(e.h2,{id:"syntax-45",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"mvn Rd, <Operand2>"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rd"})," is the destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"<Operand2>"})," tbd ",(0,r.jsx)("br",{})]}),(0,r.jsx)(e.h2,{id:"details-45",children:"Details"}),(0,r.jsxs)(e.p,{children:["One's complement ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," Rd <- NOT(Operand2)"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"neg"})," - Negate"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 86"})}),(0,r.jsx)(e.h2,{id:"syntax-46",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"neg{s} Rd, <Operand2>"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"{s}"})," (optional) determines if the instruction affects the PSTATE ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rd"})," is the destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"<Operand2>"})," tbd"]}),(0,r.jsx)(e.h2,{id:"details-46",children:"Details"}),(0,r.jsxs)(e.p,{children:["neg is an alias of sub where Rn is Zr ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," Rd <- -<Operand2>"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"ngc"})," - Negate with Carry"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 86"})}),(0,r.jsx)(e.h2,{id:"syntax-47",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"ngc{s} Rd, Rm"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"{s}"})," (optional) determines if the instruction affects the PSTATE ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rd"})," is the destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rm"})," is the register to be operated on"]}),(0,r.jsx)(e.h2,{id:"details-47",children:"Details"}),(0,r.jsxs)(e.p,{children:["ngc is an aliace of sbc where Rn is substituted with ZR ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," Rd <- -Rn + carry - 1"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"nop"})," - No Operation"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 107"})}),(0,r.jsx)(e.h2,{id:"syntax-48",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"nop"})," ",(0,r.jsx)("br",{})]}),(0,r.jsx)(e.h2,{id:"details-48",children:"Details"}),(0,r.jsx)(e.p,{children:"nop has no effects. Nop's can sometimes be inserted to optimize machine-specific code. Other times, they are used in computer attacks. They can even be used just to experiment with a debugger."})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"orn"})," - Bitwise OR NOT"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 89"})}),(0,r.jsx)(e.h2,{id:"syntax-49",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"orn Rd, Rn, <Operand2>"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rd"})," is the destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rn"})," is the first operand in the instruction ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"<Operand2>"})," tbd"]}),(0,r.jsx)(e.h2,{id:"details-49",children:"Details"}),(0,r.jsxs)(e.p,{children:["Or Rn with Not <Operand2> ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," Rd <- Rn OR NOT(<Operand2>)"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"orr"})," - Bitwise Or"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 89"})}),(0,r.jsx)(e.h2,{id:"syntax-50",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"orr Rd, Rn, <Operand2>"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rd"})," is the destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rn"})," is the first operand in the instruction ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"<Operand2>"})," tbd"]}),(0,r.jsx)(e.h2,{id:"details-50",children:"Details"}),(0,r.jsxs)(e.p,{children:["Or Rn with <Operand2> ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," Rd <- Rn OR <Operand2>"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"ret"})," - Return from Subroutine"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 72"})}),(0,r.jsx)(e.h2,{id:"syntax-51",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"ret {Xn}"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Xn"})," (optional) the return address, uses the procedure link register (LR), which is x30 if not specified"]}),(0,r.jsx)(e.h2,{id:"details-51",children:"Details"}),(0,r.jsxs)(e.p,{children:["ret is only used to return from a subroutine ",(0,r.jsx)("br",{})," Copy the link register (x30), or any other register (Xn) to the program counter (PC) ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," PC <- x30 or PC <- Xn"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"ror"})," - Rotate right"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 91"})}),(0,r.jsx)(e.h2,{id:"syntax-52",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"ror Rd, Rn, Rm"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rd"})," is the destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rn"})," the register to be rotated ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rm"})," the value is used as the rotate amount"]}),(0,r.jsx)(e.h2,{id:"details-52",children:"Details"}),(0,r.jsxs)(e.p,{children:['The ror operation rotates n bits to the right. Those bits "Wrap around and are shifted into the upper bits ',(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," Rd <- Rd[Rn-1:0]",":Rd","[sizeof(Rd)-1: rn ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," lsl, lsr, asr, and ror are redundant because the same results can be achieved with an add or and instruction.  ",(0,r.jsx)("br",{})," Although the results are identical, the use of lsl, alr, lsr, and ror mnemonics is strongly encouraged because it results in code that is much easier to read, debug, and maintain"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"sbc"})," - Subtract with Carry"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 86"})}),(0,r.jsx)(e.h2,{id:"syntax-53",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"sbc{s} Rd, Rn, Rm"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"{s}"})," (optional) determines if the instruction affects the PSTATE ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rd"})," is the destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rn"})," is the first part of the subtraction ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rm"})," is the second part of the subtraction"]}),(0,r.jsx)(e.h2,{id:"details-53",children:"Details"}),(0,r.jsxs)(e.p,{children:["the carry bit comes from the PSTATE and is added to the two operands ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," rd <- Rn - Rm + carry - 1"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"sdiv"})," - Signed divide"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 97"})}),(0,r.jsx)(e.h2,{id:"syntax-54",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"sdiv Rd, Rm, Rn"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rd"})," is the destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rm"})," is the dividend ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rn"})," is the divisor"]}),(0,r.jsx)(e.h2,{id:"details-54",children:"Details"}),(0,r.jsxs)(e.p,{children:["Signed integer division ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," Rd <- Rm/Rn"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"smaddl"})," - Signed multiply add long"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 93"})}),(0,r.jsx)(e.h2,{id:"syntax-55",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"smaddl Xd, Wn, Wm, Xa"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Xd"})," is the destination 64-bit register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Wn"})," is the 32-bit register multiplicand ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Wm"})," is the 32-bit register multiplier ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Xa"})," is the 64-bit register that is added to Wn * Wm"]}),(0,r.jsx)(e.h2,{id:"details-55",children:"Details"}),(0,r.jsxs)(e.p,{children:["Takes in 32-bit input and outputs a 64-bit output ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," Xd <- Xa + signExtend(Wm)*signExtend(Wn)"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"smnegl"})," - Signed multiply negate long"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 93"})}),(0,r.jsx)(e.h2,{id:"syntax-56",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"smnegl Xd, Wn, Wm"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Xd"})," is the 64-bit destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Wn"})," is the 32-bit multiplicand ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Wm"})," is the 32-bit multiplier"]}),(0,r.jsx)(e.h2,{id:"details-56",children:"Details"}),(0,r.jsxs)(e.p,{children:["Takes in 32-bit input and outputs a 64-bit output ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," Xd <- -(signExtend(Wn)*signExtend(Wm))"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"smulh"})," - Signed multiply high "]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 95"})}),(0,r.jsx)(e.h2,{id:"syntax-57",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"smulh Xd, Xn, Xm"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Xd"})," is the 64-bit destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Xn"})," is the 64-bit multiplicand ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Xm"})," is the 64-bit multiplier"]}),(0,r.jsx)(e.h2,{id:"details-57",children:"Details"}),(0,r.jsxs)(e.p,{children:["Calculate the upper 64 bits of the 128 product multiplication between 2 64-bit numbers. The lower 64 bits can be obtained using the mul instruction ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," Xd <- (signExtend(Xn)*signExtend(Xm))[127:64]"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"smull"})," - signed multiply long"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 93"})}),(0,r.jsx)(e.h2,{id:"syntax-58",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"smull Xd, Wn, Wm"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Xd"})," is the 64-bit destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Wn"})," is the 32-bit multiplicand ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Wm"})," is the 32-bit multiplier"]}),(0,r.jsx)(e.h2,{id:"details-58",children:"Details"}),(0,r.jsxs)(e.p,{children:["Takes in 32-bit input and outputs a 64-bit output ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," Xd <- (signExtend(Wn)*signExtend(Wm))"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"stp"})," - Store Pair"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 68"})}),(0,r.jsx)(e.h2,{id:"syntax-59",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"stp{<size>} Rt, Rt2, <addr>"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rt"})," and Rt2 are generic registers ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"<addr>"})," is 7 bits Pre-indexed, Post-indexed, or Signed immediate (Signed immediate Xt rage: [-0x200, 0x1f8]. Wt range: [-0x100, 0xfc]) ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"<size>"})," (optional) sw for signed words"]}),(0,r.jsx)(e.h2,{id:"details-59",children:"Details"}),(0,r.jsxs)(e.p,{children:["Store register pair in memory at addr ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," mem[addr] <- Rt ",(0,r.jsx)("br",{})," mem[addr + size(Rt)] <- Rt2"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"str"})," - Store Register"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 65"})}),(0,r.jsx)(e.h2,{id:"syntax-60",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"str{<size>} Rd, <addr>"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rd"})," is the destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"<addr>"})," is one of the address specifies described in (TBD) ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"<size>"})," (optional) is one of ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"b"})," unsigned byte ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"h"})," unsigned half-word ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"sb"})," signed byte ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"sh"})," signed half-word ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"sw"})," signed word"]}),(0,r.jsx)(e.h2,{id:"details-60",children:"Details"}),(0,r.jsxs)(e.p,{children:["Store register in memory at addr ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," mem[addr] <- Rd"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"stur"})," - Store Register (Unscaled)"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 67"})}),(0,r.jsx)(e.h2,{id:"syntax-61",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"stur{<size>} Rd, [Xn, #imm9]"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rd"})," is the destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"#imm9"})," the addressing mode is signed immediate with 9 bits ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"<size>"})," (optional) is either ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"b"})," unsigned byte ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"h"})," unsigned half-word"]}),(0,r.jsx)(e.h2,{id:"details-61",children:"Details"}),(0,r.jsxs)(e.p,{children:["Store register in memory at addr ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," mem[addr] <- Rd"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"sub"})," - Subtract"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 86"})}),(0,r.jsx)(e.h2,{id:"syntax-62",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"sub{s} Rd, Rn, <Operand2>"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"{s}"})," (optional) determines if the instruction affects the PSTATE ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rd"})," is the destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rn"})," is a general register to be subtracted from ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"<Operand2>"})," tbd"]}),(0,r.jsx)(e.h2,{id:"details-62",children:"Details"}),(0,r.jsxs)(e.p,{children:["Subtract <Operand2> from Rn ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," Rd <- Rn - Operand2"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"svc"})," - Supervisor Call"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 106"})}),(0,r.jsx)(e.h2,{id:"syntax-63",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"svc <syscall_number>"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"<syscall_number>"})," is encoded in the instruction. The operating system may determine which operating system service is requested"]}),(0,r.jsx)(e.h2,{id:"details-63",children:"Details"}),(0,r.jsxs)(e.p,{children:["In Linux, <syscall_number> should always just be zero. The system call number is passed in x8 and six other parameters can be passed in on x0-x5. ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," On Linux, it is generally better to make system calls by using the corresponding C library function, rather than calling them directly from assembly. This is because the C library function may perform additional work before or after making the system call. For instance, the exit library function may invoke other functions to cleanly shut down the program before it performs the exit system call."]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"tbnz"})," - Test Bit and Branch if Nonzero"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 76"})}),(0,r.jsx)(e.h2,{id:"syntax-64",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"tbnz Rt, #imm6, <label"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rt"})," is the register to be tested ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"#imm6"})," specifies which bit to test (0 to 63) ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"<label>"})," address to store in PC register, must be word aligned"]}),(0,r.jsx)(e.h2,{id:"details-64",children:"Details"}),(0,r.jsxs)(e.p,{children:["tbnz has a range of +- 32 KB ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," Conditionally branch label if specified bit in Rt is nonzero ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," if Rt[imm6] != 0 then ",(0,r.jsx)("br",{}),"     PC <- label ",(0,r.jsx)("br",{})," end if"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"tbz"})," - Test Bit and Branch if Zero"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 76"})}),(0,r.jsx)(e.h2,{id:"syntax-65",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"tbz Rt, #imm6, <label"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rt"})," is the register to be tested ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"#imm6"})," specifies which bit to test (0 to 63) ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"<label>"})," address to store in PC register, must be word aligned"]}),(0,r.jsx)(e.h2,{id:"details-65",children:"Details"}),(0,r.jsxs)(e.p,{children:["tbz has a range of +- 32 KB ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," Conditionally branch label if specified bit in Rt is zero ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," if Rt[imm6] = 0 then ",(0,r.jsx)("br",{}),"     PC <- label ",(0,r.jsx)("br",{})," end if"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"tst"})," - Test bits"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 98"})}),(0,r.jsx)(e.h2,{id:"syntax-66",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"tst Rn, <Operand2>"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rn"})," is the register to be tested ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"<Operand2>"})," tbd"]}),(0,r.jsx)(e.h2,{id:"details-66",children:"Details"}),(0,r.jsxs)(e.p,{children:["Test bits and set PSTATE ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," Rn AND <Operand2> ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," Ex. ",(0,r.jsx)("br",{})," tst w1, 0x000000001 ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," if PSTATE Z is 0 then w1 is odd, else w1 is even"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"udiv"})," - Unsigned divide"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 97"})}),(0,r.jsx)(e.h2,{id:"syntax-67",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"udiv Rd, Rm, Rn"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Rd"})," is the destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rm"})," is the dividend ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Rn"})," is the divisor"]}),(0,r.jsx)(e.h2,{id:"details-67",children:"Details"}),(0,r.jsxs)(e.p,{children:["Unsigned integer division ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," Rd <- Rm/Rn"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"umaddl"})," - Unsigned multiply long"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 93"})}),(0,r.jsx)(e.h2,{id:"syntax-68",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"umaddl Xd, Wn, Wm, Ra"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Xd"})," is a 64-bit destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Wn"})," is a 32-bit register and is the multiplicand  ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Wm"})," is a 32-bit register and is the multiplier ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Ra"})," is a general register and is added to the product"]}),(0,r.jsx)(e.h2,{id:"details-68",children:"Details"}),(0,r.jsx)(e.p,{children:"Xd <- Ra+Wn*Wm"})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"umnegl"})," - Unsigned multiply negate long"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 93"})}),(0,r.jsx)(e.h2,{id:"syntax-69",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"umnegl Xd, Wn, Wm"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Xd"})," is a 64-bit destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Wn"})," is a 32-bit register and is the multiplicand  ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Wm"})," is a 32-bit register and is the multiplier"]}),(0,r.jsx)(e.h2,{id:"details-69",children:"Details"}),(0,r.jsx)(e.p,{children:"Xd <- -(Wn*Wm)"})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"umsubl"})," - Unsigned multiply long"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 93"})}),(0,r.jsx)(e.h2,{id:"syntax-70",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"umsubl Xd, Wn, Wm, Xa"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Xd"})," is a 64-bit destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Wn"})," is a 32-bit register and is the multiplicand  ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Wm"})," is a 32-bit register and is the multiplier ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Ra"})," is a general register and is subtracted by the product"]}),(0,r.jsx)(e.h2,{id:"details-70",children:"Details"}),(0,r.jsx)(e.p,{children:"Xd <- Ra-Wn*Wm"})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"umulh"})," - Unsigned multiply high"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 95"})}),(0,r.jsx)(e.h2,{id:"syntax-71",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"umulh Xd, Xn, Xm"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Xd"})," is the 64-bit destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Xn"})," is the 64-bit multiplicand ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Xm"})," is the 64-bit multiplier"]}),(0,r.jsx)(e.h2,{id:"details-71",children:"Details"}),(0,r.jsxs)(e.p,{children:["Calculate the upper 64 bits of the 128 product multiplication between 2 64-bit numbers. The lower 64 bits can be obtained using the mul instruction ",(0,r.jsx)("br",{}),"  ",(0,r.jsx)("br",{})," Xd <- (Xn*Xm)[127:64]"]})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsxs)("summary",{children:[(0,r.jsx)(e.strong,{children:"umull"})," - Unsigned multiply long"]}),(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"pg. 93"})}),(0,r.jsx)(e.h2,{id:"syntax-72",children:"Syntax"}),(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"umull Xd, Wn, Wm"})," ",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(e.strong,{children:"Xd"})," is a 64-bit destination register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Wm"})," is a 32-bit multiplicand register ",(0,r.jsx)("br",{})," ",(0,r.jsx)(e.strong,{children:"Wn"})," is a 32-bit multiplier register"]}),(0,r.jsx)(e.h2,{id:"details-72",children:"Details"}),(0,r.jsx)(e.p,{children:"Xd <- Wn*Wm"})]})]})}function c(s={}){const{wrapper:e}={...(0,t.R)(),...s.components};return e?(0,r.jsx)(e,{...s,children:(0,r.jsx)(h,{...s})}):h(s)}},8453:(s,e,i)=>{i.d(e,{R:()=>d,x:()=>l});var n=i(6540);const r={},t=n.createContext(r);function d(s){const e=n.useContext(t);return n.useMemo((function(){return"function"==typeof s?s(e):{...e,...s}}),[e,s])}function l(s){let e;return e=s.disableParentContext?"function"==typeof s.components?s.components(r):s.components||r:d(s.components),n.createElement(t.Provider,{value:e},s.children)}}}]);